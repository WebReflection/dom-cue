const{Error:t,Event:e,EventTarget:s,Object:n,Set:a,String:r}=globalThis,{is:i}=n,l=()=>new e("change"),h=[],u=new a,c=new WeakMap,o=new WeakMap;let v=!0,g=!1;class d extends e{#t;constructor(t,e){super(e),this.#t=t}get target(){return this.#t}get currentTarget(){return this.#t}}class p extends s{#e;constructor(t){super(),this.#e=t}get value(){return g&&h.push(this),this.#e}set value(t){i(this.#e,t)||(this.#e=t,this.dispatchEvent(l()))}peek(){return this.#e}toString(){return r(this.value)}valueOf(){return this.value}}const w=t=>new p(t);class f extends p{#s;#e;#n(){const t=h.length,e=g;g=!0;try{this.#e=this.#s(),S.call(this,t)}finally{h.splice(t),g=e}}constructor(t){super(void 0),this.#s=t,this.#n()}get value(){return g&&h.push(this),this.#e}set value(e){throw new t("Computed signals are read-only")}handleEvent(t){this.#n(),this.dispatchEvent(l())}peek(){return this.#e}}const E=t=>new f(t);class y extends s{#s;#e;#n(){const t=h.length,e=g;g=!0;try{"function"==typeof this.#e&&this.#e(),this.#e=this.#s(),S.call(this,t)}finally{h.splice(t),g=e}}constructor(t){super(),this.#s=t,this.#n()}handleEvent(t){v?this.#n():u.add(this)}}const x=t=>{c.has(t)||c.set(t,new y(t))},k=t=>{const e=h.length,s=g,n=v;g=!0,v=!1;try{if(t(),u.size){const t=[...u];v=n;for(const e of t)e.handleEvent()}}finally{u.clear(),h.splice(e),g=s,v=n}},b=(t,e)=>{let s=o.get(t);return s||(s=new Map,o.set(t,s)),s.has(e)||s.set(e,new y(e.bind(void 0,new d(t,"change")))),t},M=(t,e)=>(o.get(t)?.delete(e),t);function S(t){for(const e=h.length;t<e;t++)h[t].addEventListener("change",this)}export{f as Computed,y as Effect,p as Signal,b as addSignalListener,k as batch,E as computed,x as effect,M as removeSignalListener,w as signal};
