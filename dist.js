const{Error:t,Event:e,EventTarget:s,Object:n,Set:a,String:r}=globalThis,{is:l}=n,i=()=>new e(h),u=[],h="change",c=new a,o=new WeakMap,v=new WeakMap;let g=!0,d=!1;class p extends e{#t;constructor(t){super(h),this.#t=t}get target(){return this.#t}get currentTarget(){return this.#t}}class w extends s{#e;constructor(t){super(),this.#e=t}get value(){return d&&u.push(this),this.#e}set value(t){l(this.#e,t)||(this.#e=t,this.dispatchEvent(i()))}peek(){return this.#e}toString(){return r(this.value)}valueOf(){return this.value}}const f=t=>new w(t);class E extends w{#s;#e;#n(){const t=u.length,e=d;d=!0;try{this.#e=this.#s(),T.call(this,t)}finally{u.splice(t),d=e}}constructor(t){super(void 0),this.#s=t,this.#n()}get value(){return d&&u.push(this),this.#e}set value(e){throw new t("read-only")}handleEvent(t){this.#n(),this.dispatchEvent(i())}peek(){return this.#e}}const y=t=>new E(t);class x extends s{#s;#e;#n(){const t=u.length,e=d;d=!0;try{"function"==typeof this.#e&&this.#e(),this.#e=this.#s(),T.call(this,t)}finally{u.splice(t),d=e}}constructor(t){super(),this.#s=t,this.#n()}handleEvent(t){g?this.#n():c.add(this)}}const k=t=>{o.has(t)||o.set(t,new x(t))},b=t=>{const e=u.length,s=d,n=g;d=!0,g=!1;try{if(t(),c.size){const t=[...c];c.clear(),g=n;for(const e of t)e.handleEvent()}}finally{c.clear(),u.splice(e),d=s,g=n}},M=(t,e)=>{let s=v.get(t);return s||(s=new Map,v.set(t,s)),s.has(e)||s.set(e,new x(e.bind(void 0,new p(t)))),t},S=(t,e)=>(v.get(t)?.delete(e),t);function T(t){for(const e=u.length;t<e;t++)u[t].addEventListener(h,this)}export{E as Computed,x as Effect,w as Signal,M as addSignalListener,b as batch,y as computed,k as effect,S as removeSignalListener,f as signal};
